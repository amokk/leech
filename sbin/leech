#!/bin/sh

# Author: Aleksey Tulinov <aleksey.tulinov@gmail.com>

usage() {
    echo "Usage: CONFIG_DIR=\"<DIRECTORY>\" DOWNLOADS_DIR=\"<DIRECTORY>\" $0"
    echo "Or you could omit DOWNLOADS_DIR to download files to current directory."
}

CONFIG="$CONFIG_DIR/default"

if [ ! -f $CONFIG ]; then
    echo "ERROR: No config file found at $CONFIG"
    echo
    usage
    exit 1
fi

. $CONFIG

# sanity check
#
if [ ! -f "$XSL_TEMPLATE" ]; then
    echo "ERROR: No XSL template at \"$XSL_TEMPLATE\""
    echo "You probably need to reinstall leech."
    exit 1
fi

if [ ! -f "$FOODS" ]; then
    echo "ERROR: No feeds file at \"$FOODS\""
    echo
    usage
    exit 1
fi

if [ ! -f "$DOWNLOADS" ]; then
    echo "ERROR: No downloads file at \"$DOWNLOADS\""
    echo
    usage
    exit 1
fi

if [ -z "$DOWNLOADS_DIR" ]; then
    echo "WARNING: DOWNLOADS_DIR is not set. Assuming it's current directory."
    DOWNLOADS_DIR=.
fi

if [ -z "$DOWNLOAD_DELAY" ]; then
    DOWNLOAD_DELAY=5
fi

if [ -z "$TMP" ]; then
    TMP=$DOWNLOADS_DIR
fi

if [ -z "$PERSISTENCE" ]; then
    PERSISTENCE=$DOWNLOADS_DIR
fi

# temporary file with RSS-feed
LUNCH="$TMP/leech.lunch.$$"

# wget options
#
WGET_LUNCH_OPTS="-q" # wget options for downloading lunch
WGET_DOWNLOADS_OPTS="-q --content-disposition -c -i -" # wget options for downloading files
# --content-disposition to correctly rip torrent's filename from script like torrents.php?id=xyz
# -c for not re-downloading torrents
# -i - : url (passed through stdin as output of xsltproc | grep | sed)

# misc options
#
GREP_OPTS="-i -E" # ignore case, extended regular expressions
SED_OPTS="-r -e"     # enable extended regular expressions
SED_REGEX=".* (.+)\s*\+(.+)$" # \1 is URL, \2 is datetime in RFC822
XSLT_OPTS="--novalid" # skip loading DTDs during XSL transformation

# expiration and persistence options
#
RFC822_TO_3339_STAGE1="s/(\w{3}),\s+([0-9]{2})\s+(\w{3})\s+([0-9]{4})\s+([0-9]{2}):([0-9]{2}):([0-9]{2}).*/\4-\3-\2 \5:\6:\7/" # in honor to king Leonidas
DB_REGEX="(.+) (.+)" # \1 is md5, \2 is timestamp

# prepare environment
#

# create tmp dir
if [ ! -d "$TMP" ]; then
    echo "WARNING: Temporary directory \"$TMP\" doesn't exist, creating it."
    mkdir -p "$TMP"
    if [ ! $? -eq 0 ]; then
        exit 1
    fi
fi

# remove previous lunch if any
rm -f "$LUNCH"

# create downloads dir
if [ ! -z "$DOWNLOADS_DIR" ] && [ ! -d "$DOWNLOADS_DIR" ]; then
    echo "WARNING: Downloads directory \"$DOWNLOADS_DIR\" doesn't exist, creating it."
    mkdir -p "$DOWNLOADS_DIR"
    if [ ! $? -eq 0 ]; then
        exit 1
    fi
fi

# set expiration in seconds and current time
if [ ! -z "$EXPIRATION" ]; then
    EXPIRATION=$(($EXPIRATION * 86400)) # days * seconds in a day
    NOW=$(date +%s)
fi

# create persistence dir and db
if [ ! -z "$PERSISTENCE" ]; then
    SQLITE=$(which sqlite3)
    if [ -z $SQLITE ]; then
        echo "ERROR: `sqlite3` is not found"
        echo "You probably need to install it."
        exit 1
    fi

    if [ ! -d "$PERSISTENCE" ]; then
        mkdir -p "$PERSISTENCE"
        if [ ! $? -eq 0 ]; then
            exit 1
        fi
    fi

    DB="$PERSISTENCE/leech.db"
    if [ ! -f "$DB" ]; then
        echo "WARNING: Downloads DB \"$DB\" doesn't exist, creating it"
        touch "$DB"
        if [ ! $? -eq 0 ]; then
            exit 1
        fi
    fi
fi

# downloading
#
while read FOOD
do
    # skip comments and empty strings
    TAG=$(expr substr "$FOOD" 1 1)
    case $TAG in
        '#')
            continue
            ;;
        '')
            continue
            ;;
    esac

    # download lunch
    #
    echo -n "Downloading feed: $FOOD... "
    wget "$FOOD" -O "$LUNCH" $WGET_LUNCH_OPTS

    # don't parse lunch if download failed
    #
    case $? in
        0)
            echo "OK"
            ;;

        *)
            echo "Failed"
            continue
            ;;
    esac

    # search lunch for patterns
    #
    while read PATTERN
    do
        # skip comments and empty strings
        TAG=$(expr substr "$PATTERN" 1 1)
        case $TAG in
            '#')
                continue
                ;;
            '')
                continue
                ;;
        esac

        DATA=$(xsltproc $XSLT_OPTS "$XSL_TEMPLATE" "$LUNCH" | grep $GREP_OPTS "$PATTERN")

        # download urls if any
        #
        echo "$DATA" | while read STR
        do
            if [ -z "$STR" ]; then
                continue
            fi

            URL=$(echo $STR | sed $SED_OPTS "s/$SED_REGEX/\1/")
            DATETIME=$(echo $STR | sed $SED_OPTS "s/$SED_REGEX/\2/")

            # datetime in RSS is in RFC822 format, it need to be converted to string understandable by `date`
            DATESTRING=$(echo "$DATETIME" | sed $SED_OPTS "$RFC822_TO_3339_STAGE1" | sed -e "s/Jan/01/" -e "s/Feb/02/" -e "s/Mar/03/" -e "s/Apr/04/" -e "s/May/05/" -e "s/Jun/06/" -e "s/Jul/07/" -e "s/Aug/08/" -e "s/Sep/09/" -e "s/Oct/10/" -e "s/Nov/11/" -e "s/Dec/12/")
            UNIXTIME=$(date -d "$DATESTRING" +%s)

            # if expiration set, check RSS entry pub date
            if [ ! -z $EXPIRATION ]; then
                DIFF=$(($NOW - $UNIXTIME))
                if [ $DIFF -gt $EXPIRATION ]; then
                    echo "Skipping $URL: expired"
                    continue
                fi
            fi

            # if persistence enabled - check md5 of URL for duplicates
            if [ ! -z "$DB" ]; then
                MD5=$(echo -n "$URL" | md5sum)
                MD5=$(expr substr "$MD5" 1 32)

                grep "$MD5" "$DB" 2>&1 >/dev/null
                if [ $? -eq 0 ]; then
                    echo "Skipping $URL: already downloaded"
                    continue
                fi
            fi

            echo -n "Downloading file: $URL... "

            sleep $DOWNLOAD_DELAY
            echo "$URL" | wget -P "$DOWNLOADS_DIR" $WGET_DOWNLOADS_OPTS

            case $? in
                0)
                    echo "OK"
                    ;;
                *)
                    echo "Failed"
                    ;;
            esac

            # if persistence enabled, make a record in DB about downloaded file
            if [ ! -z "$DB" ]; then
                echo "$MD5 $NOW" >> "$DB"
            fi
        done
    done <"$DOWNLOADS"

    # cleanup
    #
    rm -f "$LUNCH"

    # delete old records from DB, but only if expiration period is set
    if [ ! -z "$DB" ] && [ ! -z "$EXPIRATION" ]; then
        DB_TMP="$DB.tmp"
        rm -f "$DB_TMP" && touch "$DB_TMP"

        # write new database to tmp file
        while read LINE
        do
            TIMESTAMP=$(echo "$LINE" | sed $SED_OPTS "s/$DB_REGEX/\2/")
            if [ $(($NOW - $TIMESTAMP)) -gt $EXPIRATION ]; then
                continue
            fi

            echo "$LINE" >>"$DB_TMP"
        done <"$DB"

        # replace db with new one
        if [ -f "$DB_TMP" ]; then
            mv "$DB_TMP" "$DB"
        fi
    fi
done <"$FOODS"
